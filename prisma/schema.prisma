// prisma/schema.prisma
// Final schema with Orders (Order + OrderItem) and Purchases (Purchase + PurchaseItem)

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  // url configured via env (e.g., DATABASE_URL)
}

model User {
  id    String  @id // Stack Auth user id
  email String? @unique
  name  String?
  role  String  @default("ADMIN") // derived: ADMIN when current==default, else MEMBER

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  lastSeenAt DateTime?

  // Org pointers
  defaultOrganisationId String?
  currentOrganisationId String?

  defaultOrganisation Organisation? @relation("defaultOrg", fields: [defaultOrganisationId], references: [id], onDelete: SetNull)
  currentOrganisation Organisation? @relation("currentOrg", fields: [currentOrganisationId], references: [id], onDelete: SetNull)

  products      Product[]
  organisations Organisation[]

  @@index([defaultOrganisationId])
  @@index([currentOrganisationId])
}

model Organisation {
  id              String @id // canonical PK
  organisationId  String @unique // immutable external org id/slug
  organisationKey String @unique // immutable passkey

  // Owner snapshot + optional FK to the owner
  ownerOrgUserId    String?
  ownerOrgUsername  String?
  ownerOrgUserEmail String?
  owner             User?   @relation(fields: [ownerOrgUserId], references: [id], onDelete: SetNull)

  // Editable profile fields
  name      String?
  address1  String?
  address2  String?
  state     String?
  zipcode   String?
  country   String?
  taxNumber String?

  totalMembers Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-relations
  defaultForUsers User[]     @relation("defaultOrg")
  currentForUsers User[]     @relation("currentOrg")
  products        Product[]
  customers       Customer[]
  suppliers       Supplier[]
}

model Product {
  id             Int    @id @default(autoincrement())
  organisationId String
  userId         String
  name           String
  stock          Int    @default(0)

  // org-scoped unique fields (no global unique)
  sku String
  HSN String

  transferprice Decimal @db.Decimal(10, 2)
  price         Decimal @db.Decimal(10, 2)
  currency      String // e.g., "INR"
  taxRatePct    Decimal @db.Decimal(5, 2) // e.g., 18.00; use 0.00 for non-taxable

  // Simple category for filtering/sorting
  category String?

  productTaxDefaults Json?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-relations
  orderItems    OrderItem[]
  purchaseItems PurchaseItem[]

  user         User         @relation(fields: [userId], references: [id])
  organisation Organisation @relation(fields: [organisationId], references: [id])

  // org-scoped uniqueness
  @@unique([organisationId, sku])
  @@unique([organisationId, HSN])
  @@index([organisationId])
  @@index([userId])
  @@index([organisationId, category])
}

model Customer {
  id             Int     @id @default(autoincrement())
  organisationId String
  name           String
  address1       String?
  address2       String?
  state          String?
  country        String?
  zipcode        String?
  taxNumber      String?
  contactNumber  String?
  email          String?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders       Order[]      @relation("CustomerOrders")
  contacts     Contact[] // via Contact.customerId
  organisation Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  @@unique([organisationId, name]) // optional but useful
  @@index([organisationId])
}

model Supplier {
  id             Int     @id @default(autoincrement())
  organisationId String
  name           String
  address1       String?
  address2       String?
  state          String?
  country        String?
  zipcode        String?
  taxNumber      String?
  contactNumber  String?
  email          String?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases    Purchase[]
  contacts     Contact[] // via Contact.supplierId
  organisation Organisation @relation(fields: [organisationId], references: [id])

  @@unique([organisationId, name])
  @@index([organisationId])
}

model Contact {
  id             Int    @id @default(autoincrement())
  organisationId String

  name          String
  contactNumber String?
  email         String?

  // One side must be set (enforce in app; optional CHECK via SQL migration)
  customerId Int?
  supplierId Int?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)
  supplier Supplier? @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  // Back-relations
  orders    Order[]    @relation("OrderContact")
  purchases Purchase[] @relation("PurchaseContact")

  @@index([organisationId])
  @@index([customerId])
  @@index([supplierId])
}

//
// Orders (header + items)
//
model Order {
  id             Int    @id @default(autoincrement())
  organisationId String
  customerId     Int
  contactId      Int? // contact person (must belong to same customer/org)
  currency       String

  // snapshot of calculation
  taxInclusive Boolean @default(false)

  // Lifecycle status
  status String @default("Pending") // Pending, Cancelled, Paid

  // Autogenerated invoice number (org-scoped unique)
  invoiceNumber String

  // Totals
  subtotal       Decimal @db.Decimal(12, 2)
  totalTaxAmount Decimal @db.Decimal(12, 2)
  total          Decimal @db.Decimal(12, 2)

  taxBreakdownText  String?
  taxBreakdownJson  Json?
  additionalCharges Json?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer    @relation("CustomerOrders", fields: [customerId], references: [id], onDelete: Restrict)
  contact  Contact?    @relation("OrderContact", fields: [contactId], references: [id], onDelete: SetNull)
  items    OrderItem[]

  @@unique([organisationId, invoiceNumber])
  @@index([organisationId])
  @@index([customerId])
  @@index([contactId])
}

model OrderItem {
  id             Int    @id @default(autoincrement())
  orderId        Int
  organisationId String
  productId      Int
  productname    String

  // snapshots
  sku String
  HSN String

  quantity    Int
  unitPrice   Decimal @db.Decimal(10, 2) // snapshot of catalog unit price
  actualprice Decimal @db.Decimal(10, 2) // actual per-unit charged (after discount)
  taxRatePct  Decimal @db.Decimal(5, 2)

  lineTaxAmount Decimal @db.Decimal(12, 2)
  lineTotal     Decimal @db.Decimal(12, 2)
  currency      String?

  // Audit
  createdByEmail String
  updatedByEmail String

  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([organisationId])
  @@index([productId])
  @@index([orderId])
}

//
// Purchases (header + items) â€” mirrors Orders, affects stock
//
model Purchase {
  id             Int     @id @default(autoincrement())
  organisationId String
  supplierId     Int
  contactId      Int? // contact person (must belong to same supplier/org)
  userId         String?
  currency       String

  // snapshot of calculation
  taxInclusive Boolean @default(false)

  // Lifecycle status
  status String @default("Pending") // Pending, Posted, Paid, Cancelled

  // Optional supplier bill number (make org-unique if desired)
  poNumber String

  // Totals
  subtotal       Decimal @db.Decimal(12, 2)
  totalTaxAmount Decimal @db.Decimal(12, 2)
  total          Decimal @db.Decimal(12, 2)

  taxBreakdownText  String?
  taxBreakdownJson  Json?
  additionalCharges Json?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  supplier Supplier       @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  contact  Contact?       @relation("PurchaseContact", fields: [contactId], references: [id], onDelete: SetNull)
  items    PurchaseItem[]

  // Uncomment to enforce unique bill number per org:
  @@unique([organisationId, poNumber])
  @@index([organisationId])
  @@index([supplierId])
  @@index([contactId])
}

model PurchaseItem {
  id             Int    @id @default(autoincrement())
  purchaseId     Int
  organisationId String

  productId   Int // REQUIRED to adjust stock
  productname String
  sku         String
  HSN         String

  quantity    Int
  unitPrice   Decimal @db.Decimal(10, 2)
  actualprice Decimal @db.Decimal(10, 2) // actual per-unit charged (after discount)
  taxRatePct  Decimal @db.Decimal(5, 2)

  lineTaxAmount Decimal @db.Decimal(12, 2)
  lineTotal     Decimal @db.Decimal(12, 2)
  currency      String?

  // Audit
  createdByEmail String
  updatedByEmail String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchase Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([purchaseId])
  @@index([organisationId])
  @@index([productId])
}
